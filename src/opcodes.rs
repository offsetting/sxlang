use binrw::binrw;

#[repr(C)]
pub enum Opcode {
    PushVar = 0,
    PushMultipleVars,
    PushVarIndexed,
    PushInt,
    PushFloat,
    PushByte,
    PushByteAsFloat,
    PushString,
    Pop,
    PopAndStore,
    PopAndStoreMultiple,
    Store,
    StoreIndexed,
    Dup,
    Swap,
    PushOwner,
    LessThan,
    LessThanEq,
    GtrThan,
    GtrThanEq,
    Equal,
    NotEqual,
    Add,
    Sub,
    Mult,
    Div,
    Mod,
    Negate,
    Abs,
    ShiftL,
    ShiftR,
    LogicalAnd,
    LogicalOr,
    LogicalNot,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNot,
    BranchTrue,
    BranchFalse,
    BranchTrueNoPop,
    BranchFalseNoPop,
    Jump,
    Call,
    SysCall,
    Return,
    Switch,
    Unk2,
    Unk3,
    Unk4,
    End,
    Sleep,
    Print,
    Target,
    Nop,
}

impl From<u8> for Opcode {
    fn from(value: u8) -> Self {
        match value {
            0 => Opcode::PushVar,
            1 => Opcode::PushMultipleVars,
            2 => Opcode::PushVarIndexed,
            3 => Opcode::PushInt,
            4 => Opcode::PushFloat,
            5 => Opcode::PushByte,
            6 => Opcode::PushByteAsFloat,
            7 => Opcode::PushString,
            8 => Opcode::Pop,
            9 => Opcode::PopAndStore,
            10 => Opcode::PopAndStoreMultiple,
            11 => Opcode::Store,
            12 => Opcode::StoreIndexed,
            13 => Opcode::Dup,
            14 => Opcode::Swap,
            15 => Opcode::PushOwner,
            16 => Opcode::LessThan,
            17 => Opcode::LessThanEq,
            18 => Opcode::GtrThan,
            19 => Opcode::GtrThanEq,
            20 => Opcode::Equal,
            21 => Opcode::NotEqual,
            22 => Opcode::Add,
            23 => Opcode::Sub,
            24 => Opcode::Mult,
            25 => Opcode::Div,
            26 => Opcode::Mod,
            27 => Opcode::Negate,
            28 => Opcode::Abs,
            29 => Opcode::ShiftL,
            30 => Opcode::ShiftR,
            31 => Opcode::LogicalAnd,
            32 => Opcode::LogicalOr,
            33 => Opcode::LogicalNot,
            34 => Opcode::BitwiseAnd,
            35 => Opcode::BitwiseOr,
            36 => Opcode::BitwiseXor,
            37 => Opcode::BitwiseNot,
            38 => Opcode::BranchTrue,
            39 => Opcode::BranchFalse,
            40 => Opcode::BranchTrueNoPop,
            41 => Opcode::BranchFalseNoPop,
            42 => Opcode::Jump,
            43 => Opcode::Call,
            44 => Opcode::SysCall,
            45 => Opcode::Return,
            46 => Opcode::Switch,
            47 => Opcode::Unk2,
            48 => Opcode::Unk3,
            49 => Opcode::Unk4,
            50 => Opcode::End,
            51 => Opcode::Sleep,
            52 => Opcode::Print,
            53 => Opcode::Target,
            54 => Opcode::Nop,
            _ => panic!("Invalid opcode: {}", value),
        }
    }
}

#[binrw(little)]
#[derive(Debug)]
pub enum Instruction {
    PushVar(u16),
    // First is length, second is start index.
    PushMultipleVars(u8, u16),
    PushVarIndexed(u16),
    PushInt(i32),
    PushFloat(f32),
    PushByte(u8),
    PushByteAsFloat(u8),
    PushString(u16),
    Pop,
    PopAndStore(u16),
    PopAndStoreMultiple(u8, u16),
    Store(u16),
    StoreIndexed(u16),
    Dup,
    Swap(u16),
    PushOwner,
    LessThan,
    LessThanEq,
    GtrThan,
    GtrThanEq,
    Equal,
    NotEqual,
    Add,
    Sub,
    Mult,
    Div,
    Mod,
    Negate,
    Abs,
    ShiftL,
    ShiftR,
    LogicalAnd,
    LogicalOr,
    LogicalNot,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseNot,
    BranchTrue(u16),
    BranchFalse(u16),
    BranchTrueNoPop(u16),
    BranchFalseNoPop(u16),
    Jump(u16),
    Call(u16),
    SysCall(u16),
    Return,
    Switch(u16),
    Unk2(u16),
    Unk3,
    Unk4,
    End,
    Sleep,
    Print,
    Target,
    Nop,
}
